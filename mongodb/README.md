# MongoDB

## Key Features
### MongoDB is schema less, fast, highly scalable and supports big data. 
### Tables are Collections and Rows are Documents in MongoDB 
### Primary Key - Foreign Key relationship is achieved by embedding documents inside document. 
### Every MongoDB has a unique auto generated id (primary key) called ObjectId
### Combination of database name and a collection is called a namespace in MongoDB

Records are stored as documents (xml, json, yaml etc) -> Its an equivalant of a table in RDBMS   
No schema is followed for storing of documents and hence they are schema less   

When collections become too big they can be sharded (distributed) into the cluster -> Divide the data in the single large collection to mulitple instances of the server   
Shards can be replicated (master-slave strategy) -> Multiple copies of the shards can be stored across cluster for redudency   

Documents are RDBMS equivalant of a record within the table   
For storing documents more than 16M (mongodb limit) in size we need to use MongoDb's GridFS

## Features of MongoDB
Multi-document ACID transactions   
Type conversions   
The improved shard balancer   
The aggregation pipeline builder    
MongoDB Charts (beta)    

## Installing mongodb by 3 different ways on MAC 
1. Direct download of binary and install it   
2. brew install mongodb 
3. Docker container install  (my favourite) - [ docker run -it -p 27017:27017 --name mymongodb -d mongo:latest  ]

## Commad to enter the mongo shell using docker 
docker exec -it mymongodb mongo   
or Connect client to MongoDB - Use MongoDB Compass   


### Important elements of mongo config file (mongo.config)
```xml
bind_ip = 127.0.0.1
port = 27017
quiet = true
dbpath=D:\mongodb\data\db
logpath=D:\mongodb\log\mongo.log
logappend = true
diaglog=3
journal = true
```

## Step by Step - Commands 
```xml
show dbs -> used for listing all the databases available 
db -> will display the current database 
use myrecords -> this will create a reference to database called myrecords. Actual database is created only when we create collections in it 
db.dropDatabase() -> This will drop the current database we are in 

show collections -> This will display all the collections in the current database 
db.createCollection('students') -> this will create a new collection called students
db.createCollection('students', {
    capped : true, 
    size : 2000000, 
    max : 5000,
    autoIndexId:true
}); -> This will create a capped collection called students that will hold a maximum of 5000 documents and will rewrite once this limit has been reached 
db.students.drop() -> This will drop the collection named students
db.students.renameCollection("student") -> This will rename a collection 
```

### Insert 
```xml
db.students.insert({name:"Balaji", rollno:14, status:"present"}) -> This will insert one document into the collection and return the count of inserted records
db.students.insert({_id: 1, name:"Thiagarajan", rollno:1, status:"present"}) -> This will insert document with our own id, will throw write errror if the id exist 
db.students.insert([{name:"Havisha", rollno:2, status:"present"}, {name:"Haasya", rollno:3, status:"absent"}]) -> This is a bulk insert of more than one document
db.students.insertOne({name:"Balaji", rollno:14, status:"present"}) -> This will insert one document into the collection 'students' and will return a boolean of status and also the unique key of inserted record 
db.students.insertMany([{name:"Havisha", rollno:15, status:"present"}, {name:"Haasya", rollno:16, status:"absent"}]) -> This will insert more than one document into the collection
```

### Find
```xml
db.students.find() -> This will read all the documents in the collection
db.students.find()[0] -> This will find the first document from the collection
db.students.find()[0].name -> This will display the first document's name field 
db.students.find()[0]._id.getTimestamp() -> This will display the timestamp of when this document was created - this works for only autogenerated ids 
db.students.find().pretty() -> this will display all documents in the collection in a pretty format 
db.students.find({"status":"present", rollno:14}) -> This is a find documents with filter condition 
db.students.find({rollno:{$gte:15}}) -> This will find documents with filter condition of greater than or equal to ($gte) - for other criterias use the following $lte, $lt, $gt, $eq, $ne, $in, $nin, $exists
db.students.find({"rollno":14},{name:1, _id:0}) -> This will find all documents with rollno=14 and will display only the name field from the document 
db.students.find({},{name:0}) -> This will display all documents in the collection but will not display the name field 
db.students.find().sort({$natural:1}) -> This will display the records in the sorted order of either insert or updated records with the last inserted/updated recording comming in the last 
```

### Update 
```xml
db.students.updateOne({"rollno":15},{$set:{"name":"Havisha Balaji"}}) -> This will update the document name to Havisha Balaji where rollno is 15 (only the first match would be updated)
db.students.updateMany({"rollno":{$gte:15}},{$set:{"status":"Present Y"}}) -> This will update more than one document in the collection if the match is found
db.students.updateMany({"rollno":{$gte:10}},{$set:{"game":"Cricket"}}) -> This will add one more new column to the document in the collection if the match is found
```

### Find and modify (will return back the found document before the update)
```xml
db.students.findAndModify({query:{name:"Balaji"}, update:{$inc:{rollno:3}}}) -> This will find the name-Balaji and increment the rollno by 3 
```

### Delete (will return boolen ack along with count)
```xml
db.students.deleteOne({"rollno":15}) -> This will detele the first matching document where the rollno is 15
db.students.updateMany({"rollno":{$gte:15}}) -> This will delete all documents that have roll no. greater or equal to 15
```

### Remove (will return count of removed documents)
```xml
db.students.remove({"rollno":15}) -> This will detele the document where the rollno is 15
db.students.remove({"rollno":15}, 1) -> This will delete the first document where the rollno is 15
db.students.remove({rollno:{$gt:15}}) -> This will remove all documents that have age greater than 15 
db.students.remove({}) -> This will remove all documents from the collection
```

### Index 
```xml
db.students.find({"name":"Haasya"}).explain("executionStats") -> In order for us to understand the index lets examine the find method's execution stats before creating an index. 
                                                                ->This query will examine the entire collection to find the data ("totalKeysExamined" : 0, "totalDocsExamined" : 3)
                                                                -> explain method takes 3 parametes executionStats, queryPlanner, allPlansExecution 
db.students.find({"_id":ObjectId("60d0bc5f41cab5234e81d5b3")}).explain("executionStats") -> The same find with an indexed key will have the following ("totalKeysExamined" : 1, "totalDocsExamined" : 1)
db.students.getIndexes() -> This will display all the indexes that are available for a collection
db.students.createIndex({name:1}) -> This will create an index on the field name in ascending order and -1 for descending order 
db.students.createIndexes([ {'name',1}, {'rollno',1}], {unique,'true'}) -> This will create indexes on multiple fields and together they are unique 
db.students.dropIndex({name:1}) -> This will drop the created index 
```

### Object Id - They are primary key, immutable, unique and of bson datatype (12 bytes)
```xml
db.students.insert({_id: 1,name:"Balaji with id", rollno:45, status:"absent"}) -> This will create our own key that must be unique across all machines in the cluster (not advisable unless we have a centralized strategy for it)
```

### Aggregate - $sum, $avg, $min, $max, $first, $last
```xml
db.students.aggregate([{$group:{_id:"$status",attendance:{$sum:1}}}]) -> This will group the status field and display it as a sum of with its label as attendance 
db.students.distinct("status") -> This will display the unique data in the status field
db.students.count() -> This will display the total count of all the documents in the collection 
db.students.count({'rollno' : {$lt : 45}}) -> This will display the count of records where rollno is less than 45
db.students.find().sort({rollno:1}) -> This will sort the data by rollno in ascending order, -1 is for descending order
```

### Relationships in mongodb
```xml
1. One to One (Embedding / Referencing)

Embedding 
db.students.insert({
    name:"Balaji",
    age: 40,
    rollno:99,
    marks: 
    {
        science: 92,
        english: 89,
        maths: 99
    }
})

Referencing
db.students.insert({
    _id: 198,
    name:"Balaji",
    age: 40,
    rollno:99
})

db.marks.insert({
    student_id: 198, 
    science: 92,
    english: 89,
    maths: 99
})

2. One to Many (Embedding / Referencing)

Embedding
db.students.insert({
    name:"Balaji",
    age: 40,
    rollno:99,
    marks: [
        {
            subject_id: 9,
            science: 92
        },
        {
            subject_id: 10,
            english: 89
        },
        {
            subject_id: 3, 
            maths: 99
        }

    ]
})

Referencing
db.students.insert({
    _id: 209,
    name:"Balaji",
    age: 40,
    rollno:99
})

db.marks.insertMany([
    {
        student_id: 209,
        subject_id: 9,
        science: 92
    },
    {
        student_id: 209,
        subject_id: 10,
        english: 89
    },
    {
        student_id: 209,
        subject_id: 3,
        maths: 99
    }
])


3. Many to Many (Embedding / Referencing)
Emdedding is straight forward as before

2-Way Referencing
db.students.insert({
    _id: 209,
    name:"Balaji",
    age: 40,
    booksid: [7,9]
})

db.books.insert({
    _id: 7,
    name:"This is a Java Reference Book",
    studentid: [209,210]
})

```

### Users in mongodb
```xml
db.getUsers() -> This will list out the users in the current database
db.createUser({user:"techdata", pwd:"tech", roles:[{role:"userAdmin", db:"students"}]}) -> This will create an user called techdata with password tech and role userAdmin in database students 
```


### Regular expressions in mongodb ($regex operator)
```xml
 db.students.find({name:{$regex:"Balaji"}}) -> This will search for name equals Balaji 
 db.students.find({name:/Balaji/}) -> This is the same as above but with different format without using $regex 
 db.students.find({name:{$regex:/^B/}}) -> This will display names that start with B
 db.students.find({name:{$regex:/^b/,$options:'i'}}).pretty() -> Same as above but with case-insensitive search (i in $options stands for ignorecase)
 db.students.find({name:{$regex:/i$/}}).pretty() -> This will display the name ending with i 
 db.students.find({name:/i$/}).pretty() -> Same as above but without the $regex operator 
```

### Limit the records fetched 
```xml
db.students.find().limit(1).pretty() -> Will limit the fetched record size to 1 
db.students.find().sort({$natural:-1}).limit(1).pretty() -> Will sort in in reverse order and fetch the 1st record, ie. the last record from the previous search 
```

### Map-Reduce
```xml
Dataset for Map-Reduce 
db.loan.insert({id:101, loanid:123, amount:5000, status:"Active"});
db.loan.insert({id:101, loanid:124, amount:6000, status:"Active"});
db.loan.insert({id:102, loanid:1267, amount:15000, status:"Active"});
db.loan.insert({id:102, loanid:1268, amount:25000, status:"Active"});
db.loan.insert({id:101, loanid:125, amount:78000, status:"Expired"});
db.loan.insert({id:101, loanid:126, amount:34000, status:"Expired"});
db.loan.insert({id:101, loanid:127, amount:78000, status:"Active"});
db.loan.insert({id:102, loanid:1269, amount:78000, status:"Expired"});

This is the map reduce code and the final find will give immediate result. 
db.loan.mapReduce( 
    function() { 
        emit(this.id, this.amount); 
    },  
    function(key, values) {
        return Array.sum(values)
    }, 
    { 
        query: {status:"Active"}, 
        out:"total"
    }
).find();

To find the final output from the map reduce use the following command: 
db.total.find()


```


### Other general syntax
```xml
//load 200 documents into the collection
// Here id field is not specified and hence mongodb generates an imutable id field automatically.
// This id field can be of any data type except arrays 
for (var i = 1; i <= 200; i++){
    db.clicks.save({'field' : 'x', 'counter' : i})
}

//get all movies released in the year 2000
db.movies.find({'release_year': 1995})

//get any ten female users who are teens
db.users.find({$and : [{'age_id' : 1}, {'gender' : 'F'}]}).limit(10)

//get any ten lawyers or female users who are teens 
db.users.find({$or : [
        {'occupation' : 'Lawyer'}, 
        {$and : [{'age_id' : 1}, {'gender' : 'F'}]
    }]
}).limit(10)

//get the count of teenage female users
db.users.count({$and : [{'age_id' : 1}, {'gender' : 'F'}]})

//insert a new movie
db.movies.insertOne({
    "title" : "Avenger Endgame (2019)",
    "release_year" : 2019,
    "genres" : [
            "Fantasy",
            "Sci-Fi"
    ]
});

// insert many movies at the same time
db.movies.insertMany([
{"title" : "Glass", "release_year" : 2019, "genres" : [ "Drama", "Sci-Fi", "Thriller" ] },
{"title" : "Fighting with My Family", "release_year" : 2019, "genres" : [ "Biography", "Comedy", "Drama" ] },
{"title" : "Black Panther", "release_year" : 2018, "genres" : [ "Action", "Adventure", "Sci-Fi" ] }])

//search
db.movies.findOne()
//find functions generally take two documents
//the first part is the query predicate definition, 
//the second part controls the projection
db.movies.find({'title' : "Black Panther"}, {}) //.pretty()
//now project only the id and title
db.movies.find({'title' : "Black Panther"}, {'title' : 1, '_id' : 0})

//examples of operations
//search for the 10 Crime and Action movies
db.movies.find({$and : [{'genres' : 'Crime'}, {'genres' : 'Action'}]}).limit(10)
//and some pagnation
db.movies.find({$and : [{'genres' : 'Crime'}, {'genres' : 'Action'}]}).skip(2).limit(10)

//update 
//has to parts: query part and the updating document part
db.movies.update({'title' : "Black Panther"}, {$set : {'release_year' : 2019}})

//delete will delete all documents in the collection
db.movies.delete({})

//get the max id
db.movies.find().sort({"_id": -1}).limit(1)


//explain
db.users.find().explain()
db.users.find({'age_id' : 1}).explain()
db.users.find({$and : [{'age_id' : 1}, {'gender' : 'F'}]}).limit(10).explain()

//add executionStats to explain output
db.users.find({'age_id' : 1}).explain("executionStats")

//get indexes on the users collection
db.users.getIndexes()

//to understand the impact of index on a query, it is important to use the explain function 
db.ratings.find({'genres' : 'Action'}).explain()

//create indexes on the rating collection
db.users.createIndex({'age_id' : 1})
db.ratings.createIndexes([{'movie_id' : 1}, {'user_id': 1}], {unique: true})  //with options
//sort the ratings in descending order or time
db.ratings.createIndex({'rated_at' : -1})
//assumming a unique index on user c
db.users.createIndex({'ssn' : 1}, {unique: true}) //many other options. Check the documentaion


//create full text indexes on the tags collection and embedded title in the movie object
//weight signifies preference that should be givin for similar matching text 
db.tags.createIndex({
        'tag' : 'text',
        'movie.title' : 'text'
    }, 
    {
        'weights' : {
            'tag' : 5,
            'movie.title' : 10
        },
        'name' : 'tag_text_idx'
})

//search using text index
db.tags.find( { $text: { $search: "bitter" } }, {'tag': 1, 'movie.title' : 1} )

//add the score of the relevance to the search
db.tags.find( 
    { $text: { $search: "awesome romance" }},
    { score: { $meta: "textScore" } } 
)

//sort by the score of the relevance to the search
db.tags.find( 
    { $text: { $search: "awesome romance" }},
    { score: { $meta: "textScore" } } 
).sort({score: { $meta: "textScore"}})

//drop movie_id and user_id indexes on the rating collection
db.ratings.dropIndex('idx44')

//joining ratings and user table

//get all ratings where the user gave a 5 star review
db.ratings.aggregate([
    {$match : {"rating" : 5}},
    {$lookup : {
            from : 'users',
            localField: 'user_id',
            foreignField: '_id',
            as: 'user'
        }
    },
    {$unwind : '$user'}
])


//fetch a frequency of genre of movies per year for all years
var mapFn = function(){
    var genres = this.genres;
    var year = this.release_year;
    //emit each genre as count 1
    for (var i = 0; i < genres.length; i++)
        emit({'year': year, 'genre': genres[i]}, 1);
}

var reduceFn = function(key, values) {
    return Array.sum(values);
}

db.movies.mapReduce(mapFn, reduceFn, {out: {inline: 1}, query: {}}) //outputs to screen

db.movies.mapReduce(mapFn, reduceFn, {out: 'genre_yearly_hist', query: {}}) //outputs to a collection

//we will now query the genre_yearly_hist table
//get the frequency distribution of genres in a particular year. Order by frequency in descending order
db.genre_yearly_hist.find({'_id.year' : 1999}, {}).sort({'value': -1})

//get the number of movies for a particular genre through the years
db.genre_yearly_hist.find({'_id.genre' : 'Action'}, {}).sort({'_id.year': -1})

// sql equivalent
//select genre, release_year as year, count(1) from v_movie_genre group by genre, release_year;


//fetch a histogram of genre of movies per year for all years
db.movies.aggregate([
    {$project : {'release_year' : 1, 'genres' : 1, '_id' : 0}},
    {$unwind : '$genres'},
    {$group : {
        _id : { 'year' : '$release_year', 'genre' : '$genres'},
        value : {$sum : 1}
    }},
    // {$match : {'_id.year' : 2000}}
])

// sql equivalent
//select genre, release_year as year, count(1) from v_movie_genre group by genre, release_year;

//fetch the summary ratings for all movies by demographics of viewers
db.ratings.aggregate([
    {$lookup : {
            from : 'movies',
            localField: 'movie_id',
            foreignField: '_id',
            as: 'movie'
        }
    },
    {$unwind : '$movie'},
    {$project : {'rating' : 1, 'movie.title' : 1, 'movie_id' : 1, 'user_id' : 1, '_id': 0}},
    {$lookup : {
            from : 'users',
            localField: 'user_id',
            foreignField: '_id',
            as: 'user'
        }
    },
    {$unwind : '$user'},
    {$project : {'rating' : 1, 'movie.title' : 1, 'movie_id' : 1, 'user_id' : 1, 'user.age_group': 1, 'user.occupation': 1}},
        {$group: {
                '_id' : {'age' : 'movie_id'},
                'k' : {$sum : 1}
            }
        }
])



//select age_group, occupation, count(1) no_movies, sum(rating) total_ratings, 
//avg(rating) average_rating, variance(rating) from v_rating 
//group by age_group, occupation;


// fetch the summary ratings for all movies by demographics of viewers by genre by yearMonth
db.ratings_v2.aggregate([
    {$project : {'rating' : 1, 'ryear' : {'$year' : '$rated_at'} ,  'rmonth' : {'$month' : '$rated_at'} , 'movie.title' : 1, 'movie_id' : 1, 'user.age_group' : 1, 'user.occupation' : 1, 'movie.genres':1, '_id' : 0}},
    {$unwind : '$movie.genres'},
    {$group : {
                '_id' : {'year' : '$ryear', 'month' : '$rmonth', 'title' : '$movie.title', 'age_group' : '$user.age_group', 'occupation' : '$user.occupation', 'genre' : '$movie.genres'},
                'no_rating' : {$sum : 1},
                'average_rating' : {$avg : '$rating'},
                'var_rating' : { $pow: [ { '$stdDevPop' : '$rating' }, 2 ] } ,
        }
    }
])


// select age_group, occupation, gm.genre, monthname(r.rated_at) monthname, count(1) no_movies from v_rating r
//  join v_movie_genre gm on gm.movie_id = r.movie_id
// group by age_group, occupation, gm.genre, monthname;

```

## Node.js (Quick notes)
### Install node js (https://nodejs.org/en/download/)
```xml
node -> Enter the REPL mode -> Read / Evaluate / Print / Loop -> Test  
const repl=require('repl') -> Store the repl commands into a constant 
repl -> View the constant 
.help -> Will display all commands that we can use 
console.log("hello world") -> This will print in the console 
var sum = function(a,b) {return a+b;}; -> this will create a function and store it into variable sum
sum(9,99) -> This will call the function and print the result 
a=5
do { 
... a++;
... console.log("a = "+a);
... }
while (a<10); -> This will print the values of a>5 until a <11, we can save the same in a js file and run with 
node <filename>.js
npm -> Node package manager 
npm --version -> this will give the version of the installed npm 
npm list -g -> To list globally installed packages
npm list -g --depth=1 -> To list globally installed packages to a depth of 1 level
npm list -> To list locally installed packages

Create a file called hello.js
var http=require("http");
http.createServer(function(request,response) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end("Hello World!!\n");
}).listen(8081);

console.log('server started at http://127.0.0.1:8081/');

run the file with the following command
node hello.js

launch the browser and access the page http://127.0.0.1:8081

npm init-> This will initize the node project 

>>>>To complete connection to MongoDB>>>>>>

```


## Simple Springboot application to connect to MongoDB and perform CRUD operations
### Application name: simple-crud-samples
In pom.xml add the following dependencies:   
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```
Create an Entity, a repository interface that extends MongoRepository and start using the repository for all the basic operations just like any regular Spring Data JPA / RDBMS samples.   

## Simple maven application to connect to MongoDB and perform CRUD operations
### Application name: plain-maven-crud-sample
In pom.xml add the following dependencies:   
```xml
<dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongo-java-driver</artifactId>
    <version>3.12.7</version>
</dependency>
```

```xml

MongoClient mongoClient = new MongoClient(new MongoClientURI("mongodb://host1:27017")); // where host1 is your mongodb host name 
MongoDatabase database = mongoClient.getDatabase("test");
MongoCollection<Document> collection = database.getCollection("employee");

collection.find().forEach((Consumer<Document>) doc -> System.out.println(doc));
mongoClient.close();
```


References:   
https://spring.io/guides/gs/accessing-data-mongodb/    
https://docs.mongodb.com/manual/reference   
https://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/




